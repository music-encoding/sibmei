
{
    
    _License "() {
    return 'Copyright (c) 2011-2015 Andrew Hankinson, Alastair Porter, and Others

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    Software), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.';
    }"

    
Arpeg "() {
    CreateElement('arpeg', null);
}"

Attacca "() {
    CreateElement('attacca', null);
}"

BTrem "() {
    CreateElement('bTrem', null);
}"

Beam "() {
    CreateElement('beam', null);
}"

BeamSpan "() {
    CreateElement('beamSpan', null);
}"

BeatRpt "() {
    CreateElement('beatRpt', null);
}"

Bend "() {
    CreateElement('bend', null);
}"

BracketSpan "() {
    CreateElement('bracketSpan', null);
}"

Breath "() {
    CreateElement('breath', null);
}"

FTrem "() {
    CreateElement('fTrem', null);
}"

Fermata "() {
    CreateElement('fermata', null);
}"

Gliss "() {
    CreateElement('gliss', null);
}"

GraceGrp "() {
    CreateElement('graceGrp', null);
}"

Hairpin "() {
    CreateElement('hairpin', null);
}"

HalfmRpt "() {
    CreateElement('halfmRpt', null);
}"

HarpPedal "() {
    CreateElement('harpPedal', null);
}"

Lv "() {
    CreateElement('lv', null);
}"

MNum "() {
    CreateElement('mNum', null);
}"

MRest "() {
    CreateElement('mRest', null);
}"

MRpt "() {
    CreateElement('mRpt', null);
}"

MRpt2 "() {
    CreateElement('mRpt2', null);
}"

MSpace "() {
    CreateElement('mSpace', null);
}"

Measure "() {
    CreateElement('measure', null);
}"

MeterSig "() {
    CreateElement('meterSig', null);
}"

MeterSigGrp "() {
    CreateElement('meterSigGrp', null);
}"

MultiRest "() {
    CreateElement('multiRest', null);
}"

MultiRpt "() {
    CreateElement('multiRpt', null);
}"

OLayer "() {
    CreateElement('oLayer', null);
}"

OStaff "() {
    CreateElement('oStaff', null);
}"

Octave "() {
    CreateElement('octave', null);
}"

Ossia "() {
    CreateElement('ossia', null);
}"

Pedal "() {
    CreateElement('pedal', null);
}"

Reh "() {
    CreateElement('reh', null);
}"

Slur "() {
    CreateElement('slur', null);
}"

Tie "() {
    CreateElement('tie', null);
}"

Tuplet "() {
    CreateElement('tuplet', null);
}"

TupletSpan "() {
    CreateElement('tupletSpan', null);
}"

Mordent "() {
    CreateElement('mordent', null);
}"

Trill "() {
    CreateElement('trill', null);
}"

Turn "() {
    CreateElement('turn', null);
}"

MeiCorpus "() {
    CreateElement('meiCorpus', null);
}"

App "() {
    CreateElement('app', null);
}"

Lem "() {
    CreateElement('lem', null);
}"

Rdg "() {
    CreateElement('rdg', null);
}"

Sp "() {
    CreateElement('sp', null);
}"

StageDir "() {
    CreateElement('stageDir', null);
}"

Abbr "() {
    CreateElement('abbr', null);
}"

Add "() {
    CreateElement('add', null);
}"

Choice "() {
    CreateElement('choice', null);
}"

Corr "() {
    CreateElement('corr', null);
}"

CpMark "() {
    CreateElement('cpMark', null);
}"

Damage "() {
    CreateElement('damage', null);
}"

Del "() {
    CreateElement('del', null);
}"

Expan "() {
    CreateElement('expan', null);
}"

Gap "() {
    CreateElement('gap', null);
}"

HandShift "() {
    CreateElement('handShift', null);
}"

MetaMark "() {
    CreateElement('metaMark', null);
}"

Orig "() {
    CreateElement('orig', null);
}"

Reg "() {
    CreateElement('reg', null);
}"

Restore "() {
    CreateElement('restore', null);
}"

Sic "() {
    CreateElement('sic', null);
}"

Subst "() {
    CreateElement('subst', null);
}"

Supplied "() {
    CreateElement('supplied', null);
}"

Unclear "() {
    CreateElement('unclear', null);
}"

Facsimile "() {
    CreateElement('facsimile', null);
}"

Surface "() {
    CreateElement('surface', null);
}"

Zone "() {
    CreateElement('zone', null);
}"

Fig "() {
    CreateElement('fig', null);
}"

FigDesc "() {
    CreateElement('figDesc', null);
}"

Graphic "() {
    CreateElement('graphic', null);
}"

Table "() {
    CreateElement('table', null);
}"

Td "() {
    CreateElement('td', null);
}"

Th "() {
    CreateElement('th', null);
}"

Tr "() {
    CreateElement('tr', null);
}"

Fing "() {
    CreateElement('fing', null);
}"

FingGrp "() {
    CreateElement('fingGrp', null);
}"

Expression "() {
    CreateElement('expression', null);
}"

ExpressionList "() {
    CreateElement('expressionList', null);
}"

Item "() {
    CreateElement('item', null);
}"

ItemList "() {
    CreateElement('itemList', null);
}"

Manifestation "() {
    CreateElement('manifestation', null);
}"

ManifestationList "() {
    CreateElement('manifestationList', null);
}"

GenDesc "() {
    CreateElement('genDesc', null);
}"

GenState "() {
    CreateElement('genState', null);
}"

ChordDef "() {
    CreateElement('chordDef', null);
}"

ChordMember "() {
    CreateElement('chordMember', null);
}"

ChordTable "() {
    CreateElement('chordTable', null);
}"

F "() {
    CreateElement('f', null);
}"

Fb "() {
    CreateElement('fb', null);
}"

Harm "() {
    CreateElement('harm', null);
}"

AccessRestrict "() {
    CreateElement('accessRestrict', null);
}"

Acquisition "() {
    CreateElement('acquisition', null);
}"

AltId "() {
    CreateElement('altId', null);
}"

AppInfo "() {
    CreateElement('appInfo', null);
}"

Application "() {
    CreateElement('application', null);
}"

AttUsage "() {
    CreateElement('attUsage', null);
}"

Audience "() {
    CreateElement('audience', null);
}"

Availability "() {
    CreateElement('availability', null);
}"

Bifolium "() {
    CreateElement('bifolium', null);
}"

Byline "() {
    CreateElement('byline', null);
}"

CaptureMode "() {
    CreateElement('captureMode', null);
}"

CarrierForm "() {
    CreateElement('carrierForm', null);
}"

CatRel "() {
    CreateElement('catRel', null);
}"

Category "() {
    CreateElement('category', null);
}"

Change "() {
    CreateElement('change', null);
}"

ChangeDesc "() {
    CreateElement('changeDesc', null);
}"

ClassDecls "() {
    CreateElement('classDecls', null);
}"

Classification "() {
    CreateElement('classification', null);
}"

ComponentList "() {
    CreateElement('componentList', null);
}"

Condition "() {
    CreateElement('condition', null);
}"

ContentItem "() {
    CreateElement('contentItem', null);
}"

Contents "() {
    CreateElement('contents', null);
}"

Context "() {
    CreateElement('context', null);
}"

Correction "() {
    CreateElement('correction', null);
}"

Cutout "() {
    CreateElement('cutout', null);
}"

Dedication "() {
    CreateElement('dedication', null);
}"

DomainsDecl "() {
    CreateElement('domainsDecl', null);
}"

EditionStmt "() {
    CreateElement('editionStmt', null);
}"

EditorialDecl "() {
    CreateElement('editorialDecl', null);
}"

EncodingDesc "() {
    CreateElement('encodingDesc', null);
}"

ExhibHist "() {
    CreateElement('exhibHist', null);
}"

ExtMeta "() {
    CreateElement('extMeta', null);
}"

FileChar "() {
    CreateElement('fileChar', null);
}"

FileDesc "() {
    CreateElement('fileDesc', null);
}"

Fingerprint "() {
    CreateElement('fingerprint', null);
}"

FoliaDesc "() {
    CreateElement('foliaDesc', null);
}"

Folium "() {
    CreateElement('folium', null);
}"

Hand "() {
    CreateElement('hand', null);
}"

HandList "() {
    CreateElement('handList', null);
}"

History "() {
    CreateElement('history', null);
}"

IncipCode "() {
    CreateElement('incipCode', null);
}"

IncipText "() {
    CreateElement('incipText', null);
}"

Inscription "() {
    CreateElement('inscription', null);
}"

Interpretation "() {
    CreateElement('interpretation', null);
}"

Key "() {
    CreateElement('key', null);
}"

LangUsage "() {
    CreateElement('langUsage', null);
}"

Language "() {
    CreateElement('language', null);
}"

MeiHead "() {
    CreateElement('meiHead', null);
}"

Mensuration "() {
    CreateElement('mensuration', null);
}"

Meter "() {
    CreateElement('meter', null);
}"

Namespace "() {
    CreateElement('namespace', null);
}"

Normalization "() {
    CreateElement('normalization', null);
}"

NotesStmt "() {
    CreateElement('notesStmt', null);
}"

OtherChar "() {
    CreateElement('otherChar', null);
}"

Patch "() {
    CreateElement('patch', null);
}"

PerfDuration "() {
    CreateElement('perfDuration', null);
}"

PerfMedium "() {
    CreateElement('perfMedium', null);
}"

PerfRes "() {
    CreateElement('perfRes', null);
}"

PerfResList "() {
    CreateElement('perfResList', null);
}"

PhysDesc "() {
    CreateElement('physDesc', null);
}"

PhysMedium "() {
    CreateElement('physMedium', null);
}"

PlateNum "() {
    CreateElement('plateNum', null);
}"

PlayingSpeed "() {
    CreateElement('playingSpeed', null);
}"

Price "() {
    CreateElement('price', null);
}"

ProjectDesc "() {
    CreateElement('projectDesc', null);
}"

Provenance "() {
    CreateElement('provenance', null);
}"

PubStmt "() {
    CreateElement('pubStmt', null);
}"

RevisionDesc "() {
    CreateElement('revisionDesc', null);
}"

SamplingDecl "() {
    CreateElement('samplingDecl', null);
}"

ScoreFormat "() {
    CreateElement('scoreFormat', null);
}"

Segmentation "() {
    CreateElement('segmentation', null);
}"

SeriesStmt "() {
    CreateElement('seriesStmt', null);
}"

SoundChan "() {
    CreateElement('soundChan', null);
}"

Source "() {
    CreateElement('source', null);
}"

SourceDesc "() {
    CreateElement('sourceDesc', null);
}"

SpecRepro "() {
    CreateElement('specRepro', null);
}"

StdVals "() {
    CreateElement('stdVals', null);
}"

SysReq "() {
    CreateElement('sysReq', null);
}"

TagUsage "() {
    CreateElement('tagUsage', null);
}"

TagsDecl "() {
    CreateElement('tagsDecl', null);
}"

Taxonomy "() {
    CreateElement('taxonomy', null);
}"

TermList "() {
    CreateElement('termList', null);
}"

TitleStmt "() {
    CreateElement('titleStmt', null);
}"

TrackConfig "() {
    CreateElement('trackConfig', null);
}"

TreatHist "() {
    CreateElement('treatHist', null);
}"

TreatSched "() {
    CreateElement('treatSched', null);
}"

Unpub "() {
    CreateElement('unpub', null);
}"

UseRestrict "() {
    CreateElement('useRestrict', null);
}"

Watermark "() {
    CreateElement('watermark', null);
}"

Work "() {
    CreateElement('work', null);
}"

WorkList "() {
    CreateElement('workList', null);
}"

Refrain "() {
    CreateElement('refrain', null);
}"

Verse "() {
    CreateElement('verse', null);
}"

Volta "() {
    CreateElement('volta', null);
}"

Ligature "() {
    CreateElement('ligature', null);
}"

Mensur "() {
    CreateElement('mensur', null);
}"

Proport "() {
    CreateElement('proport', null);
}"

Stem "() {
    CreateElement('stem', null);
}"

Cc "() {
    CreateElement('cc', null);
}"

Chan "() {
    CreateElement('chan', null);
}"

ChanPr "() {
    CreateElement('chanPr', null);
}"

Cue "() {
    CreateElement('cue', null);
}"

Hex "() {
    CreateElement('hex', null);
}"

InstrDef "() {
    CreateElement('instrDef', null);
}"

InstrGrp "() {
    CreateElement('instrGrp', null);
}"

Marker "() {
    CreateElement('marker', null);
}"

MetaText "() {
    CreateElement('metaText', null);
}"

Midi "() {
    CreateElement('midi', null);
}"

NoteOff "() {
    CreateElement('noteOff', null);
}"

NoteOn "() {
    CreateElement('noteOn', null);
}"

Port "() {
    CreateElement('port', null);
}"

Prog "() {
    CreateElement('prog', null);
}"

SeqNum "() {
    CreateElement('seqNum', null);
}"

TrkName "() {
    CreateElement('trkName', null);
}"

Vel "() {
    CreateElement('vel', null);
}"

AccMat "() {
    CreateElement('accMat', null);
}"

AddDesc "() {
    CreateElement('addDesc', null);
}"

Binding "() {
    CreateElement('binding', null);
}"

BindingDesc "() {
    CreateElement('bindingDesc', null);
}"

Catchwords "() {
    CreateElement('catchwords', null);
}"

Collation "() {
    CreateElement('collation', null);
}"

Colophon "() {
    CreateElement('colophon', null);
}"

DecoDesc "() {
    CreateElement('decoDesc', null);
}"

DecoNote "() {
    CreateElement('decoNote', null);
}"

Explicit "() {
    CreateElement('explicit', null);
}"

Foliation "() {
    CreateElement('foliation', null);
}"

Heraldry "() {
    CreateElement('heraldry', null);
}"

Layout "() {
    CreateElement('layout', null);
}"

LayoutDesc "() {
    CreateElement('layoutDesc', null);
}"

Locus "() {
    CreateElement('locus', null);
}"

LocusGrp "() {
    CreateElement('locusGrp', null);
}"

Rubric "() {
    CreateElement('rubric', null);
}"

ScriptDesc "() {
    CreateElement('scriptDesc', null);
}"

ScriptNote "() {
    CreateElement('scriptNote', null);
}"

Seal "() {
    CreateElement('seal', null);
}"

SealDesc "() {
    CreateElement('sealDesc', null);
}"

SecFolio "() {
    CreateElement('secFolio', null);
}"

Signatures "() {
    CreateElement('signatures', null);
}"

Stamp "() {
    CreateElement('stamp', null);
}"

Support "() {
    CreateElement('support', null);
}"

SupportDesc "() {
    CreateElement('supportDesc', null);
}"

TypeDesc "() {
    CreateElement('typeDesc', null);
}"

TypeNote "() {
    CreateElement('typeNote', null);
}"

AddName "() {
    CreateElement('addName', null);
}"

Bloc "() {
    CreateElement('bloc', null);
}"

CorpName "() {
    CreateElement('corpName', null);
}"

Country "() {
    CreateElement('country', null);
}"

District "() {
    CreateElement('district', null);
}"

FamName "() {
    CreateElement('famName', null);
}"

ForeName "() {
    CreateElement('foreName', null);
}"

GenName "() {
    CreateElement('genName', null);
}"

GeogFeat "() {
    CreateElement('geogFeat', null);
}"

GeogName "() {
    CreateElement('geogName', null);
}"

NameLink "() {
    CreateElement('nameLink', null);
}"

PeriodName "() {
    CreateElement('periodName', null);
}"

PersName "() {
    CreateElement('persName', null);
}"

PostBox "() {
    CreateElement('postBox', null);
}"

PostCode "() {
    CreateElement('postCode', null);
}"

Region "() {
    CreateElement('region', null);
}"

RoleName "() {
    CreateElement('roleName', null);
}"

Settlement "() {
    CreateElement('settlement', null);
}"

Street "() {
    CreateElement('street', null);
}"

StyleName "() {
    CreateElement('styleName', null);
}"

Episema "() {
    CreateElement('episema', null);
}"

HispanTick "() {
    CreateElement('hispanTick', null);
}"

Liquescent "() {
    CreateElement('liquescent', null);
}"

Nc "() {
    CreateElement('nc', null);
}"

NcGrp "() {
    CreateElement('ncGrp', null);
}"

Neume "() {
    CreateElement('neume', null);
}"

Oriscus "() {
    CreateElement('oriscus', null);
}"

Quilisma "() {
    CreateElement('quilisma', null);
}"

SignifLet "() {
    CreateElement('signifLet', null);
}"

Strophicus "() {
    CreateElement('strophicus', null);
}"

Syllable "() {
    CreateElement('syllable', null);
}"

AvFile "() {
    CreateElement('avFile', null);
}"

Clip "() {
    CreateElement('clip', null);
}"

Performance "() {
    CreateElement('performance', null);
}"

Recording "() {
    CreateElement('recording', null);
}"

When "() {
    CreateElement('when', null);
}"

Ptr "() {
    CreateElement('ptr', null);
}"

Ref "() {
    CreateElement('ref', null);
}"

Accid "() {
    CreateElement('accid', null);
}"

Actor "() {
    CreateElement('actor', null);
}"

AddrLine "() {
    CreateElement('addrLine', null);
}"

Address "() {
    CreateElement('address', null);
}"

AmbNote "() {
    CreateElement('ambNote', null);
}"

Ambitus "() {
    CreateElement('ambitus', null);
}"

Analytic "() {
    CreateElement('analytic', null);
}"

Annot "() {
    CreateElement('annot', null);
}"

Arranger "() {
    CreateElement('arranger', null);
}"

Artic "() {
    CreateElement('artic', null);
}"

Author "() {
    CreateElement('author', null);
}"

BarLine "() {
    CreateElement('barLine', null);
}"

Bibl "() {
    CreateElement('bibl', null);
}"

BiblList "() {
    CreateElement('biblList', null);
}"

BiblScope "() {
    CreateElement('biblScope', null);
}"

BiblStruct "() {
    CreateElement('biblStruct', null);
}"

Body "() {
    CreateElement('body', null);
}"

Caesura "() {
    CreateElement('caesura', null);
}"

Caption "() {
    CreateElement('caption', null);
}"

CastGrp "() {
    CreateElement('castGrp', null);
}"

CastItem "() {
    CreateElement('castItem', null);
}"

CastList "() {
    CreateElement('castList', null);
}"

Cb "() {
    CreateElement('cb', null);
}"

Chord "() {
    CreateElement('chord', null);
}"

Clef "() {
    CreateElement('clef', null);
}"

ClefGrp "() {
    CreateElement('clefGrp', null);
}"

ColLayout "() {
    CreateElement('colLayout', null);
}"

Composer "() {
    CreateElement('composer', null);
}"

Contributor "() {
    CreateElement('contributor', null);
}"

Creation "() {
    CreateElement('creation', null);
}"

Custos "() {
    CreateElement('custos', null);
}"

Date "() {
    CreateElement('date', null);
}"

Dedicatee "() {
    CreateElement('dedicatee', null);
}"

Depth "() {
    CreateElement('depth', null);
}"

Desc "() {
    CreateElement('desc', null);
}"

Dim "() {
    CreateElement('dim', null);
}"

Dimensions "() {
    CreateElement('dimensions', null);
}"

Dir "() {
    CreateElement('dir', null);
}"

Distributor "() {
    CreateElement('distributor', null);
}"

Div "() {
    CreateElement('div', null);
}"

Dot "() {
    CreateElement('dot', null);
}"

Dynam "() {
    CreateElement('dynam', null);
}"

Edition "() {
    CreateElement('edition', null);
}"

Editor "() {
    CreateElement('editor', null);
}"

Ending "() {
    CreateElement('ending', null);
}"

Event "() {
    CreateElement('event', null);
}"

EventList "() {
    CreateElement('eventList', null);
}"

Expansion "() {
    CreateElement('expansion', null);
}"

Extent "() {
    CreateElement('extent', null);
}"

Funder "() {
    CreateElement('funder', null);
}"

Genre "() {
    CreateElement('genre', null);
}"

Group "() {
    CreateElement('group', null);
}"

GrpSym "() {
    CreateElement('grpSym', null);
}"

Head "() {
    CreateElement('head', null);
}"

Height "() {
    CreateElement('height', null);
}"

Identifier "() {
    CreateElement('identifier', null);
}"

Imprint "() {
    CreateElement('imprint', null);
}"

Incip "() {
    CreateElement('incip', null);
}"

KeyAccid "() {
    CreateElement('keyAccid', null);
}"

KeySig "() {
    CreateElement('keySig', null);
}"

Label "() {
    CreateElement('label', null);
}"

LabelAbbr "() {
    CreateElement('labelAbbr', null);
}"

Layer "() {
    CreateElement('layer', null);
}"

LayerDef "() {
    CreateElement('layerDef', null);
}"

Lb "() {
    CreateElement('lb', null);
}"

Lg "() {
    CreateElement('lg', null);
}"

Librettist "() {
    CreateElement('librettist', null);
}"

Lyricist "() {
    CreateElement('lyricist', null);
}"

Mdiv "() {
    CreateElement('mdiv', null);
}"

Mei "() {
    CreateElement('mei', null);
}"

Monogr "() {
    CreateElement('monogr', null);
}"

Music "() {
    CreateElement('music', null);
}"

Name "() {
    CreateElement('name', null);
}"

Note "() {
    CreateElement('note', null);
}"

Num "() {
    CreateElement('num', null);
}"

Ornam "() {
    CreateElement('ornam', null);
}"

P "() {
    CreateElement('p', null);
}"

Pad "() {
    CreateElement('pad', null);
}"

Part "() {
    CreateElement('part', null);
}"

Parts "() {
    CreateElement('parts', null);
}"

Pb "() {
    CreateElement('pb', null);
}"

PgDesc "() {
    CreateElement('pgDesc', null);
}"

PgFoot "() {
    CreateElement('pgFoot', null);
}"

PgFoot2 "() {
    CreateElement('pgFoot2', null);
}"

PgHead "() {
    CreateElement('pgHead', null);
}"

PgHead2 "() {
    CreateElement('pgHead2', null);
}"

Phrase "() {
    CreateElement('phrase', null);
}"

PhysLoc "() {
    CreateElement('physLoc', null);
}"

PubPlace "() {
    CreateElement('pubPlace', null);
}"

Publisher "() {
    CreateElement('publisher', null);
}"

Recipient "() {
    CreateElement('recipient', null);
}"

RelatedItem "() {
    CreateElement('relatedItem', null);
}"

Relation "() {
    CreateElement('relation', null);
}"

RelationList "() {
    CreateElement('relationList', null);
}"

Rend "() {
    CreateElement('rend', null);
}"

Repository "() {
    CreateElement('repository', null);
}"

Resp "() {
    CreateElement('resp', null);
}"

RespStmt "() {
    CreateElement('respStmt', null);
}"

Rest "() {
    CreateElement('rest', null);
}"

Role "() {
    CreateElement('role', null);
}"

RoleDesc "() {
    CreateElement('roleDesc', null);
}"

Sb "() {
    CreateElement('sb', null);
}"

Score "() {
    CreateElement('score', null);
}"

ScoreDef "() {
    CreateElement('scoreDef', null);
}"

Section "() {
    CreateElement('section', null);
}"

Series "() {
    CreateElement('series', null);
}"

Space "() {
    CreateElement('space', null);
}"

Speaker "() {
    CreateElement('speaker', null);
}"

Sponsor "() {
    CreateElement('sponsor', null);
}"

Stack "() {
    CreateElement('stack', null);
}"

Staff "() {
    CreateElement('staff', null);
}"

StaffDef "() {
    CreateElement('staffDef', null);
}"

StaffGrp "() {
    CreateElement('staffGrp', null);
}"

Syl "() {
    CreateElement('syl', null);
}"

Symbol "() {
    CreateElement('symbol', null);
}"

Tempo "() {
    CreateElement('tempo', null);
}"

Term "() {
    CreateElement('term', null);
}"

TextLang "() {
    CreateElement('textLang', null);
}"

Title "() {
    CreateElement('title', null);
}"

TitlePage "() {
    CreateElement('titlePage', null);
}"

TitlePart "() {
    CreateElement('titlePart', null);
}"

Width "() {
    CreateElement('width', null);
}"

Barre "() {
    CreateElement('barre', null);
}"

Argument "() {
    CreateElement('argument', null);
}"

Back "() {
    CreateElement('back', null);
}"

Epigraph "() {
    CreateElement('epigraph', null);
}"

Front "() {
    CreateElement('front', null);
}"

Imprimatur "() {
    CreateElement('imprimatur', null);
}"

L "() {
    CreateElement('l', null);
}"

Li "() {
    CreateElement('li', null);
}"

List "() {
    CreateElement('list', null);
}"

Q "() {
    CreateElement('q', null);
}"

Quote "() {
    CreateElement('quote', null);
}"

Seg "() {
    CreateElement('seg', null);
}"

AnchoredText "() {
    CreateElement('anchoredText', null);
}"

Curve "() {
    CreateElement('curve', null);
}"

Line "() {
    CreateElement('line', null);
}"

Mapping "() {
    CreateElement('mapping', null);
}"

PropName "() {
    CreateElement('propName', null);
}"

PropValue "() {
    CreateElement('propValue', null);
}"

SymName "() {
    CreateElement('symName', null);
}"

SymProp "() {
    CreateElement('symProp', null);
}"

SymbolDef "() {
    CreateElement('symbolDef', null);
}"

SymbolTable "() {
    CreateElement('symbolTable', null);
}"

    
Initialize "() {
        tree_doc = CreateSparseArray();
        flat_doc = CreateDictionary();
        id_incr = 0;

        Self._property:MEIDocument = tree_doc;
        Self._property:MEIFlattened = flat_doc;
        Self._property:MEIID = id_incr;
}"

    XMLComment "(comment) {
    commentObj = CreateElement('<!--', null);
    commentObj.text = comment;
    return commentObj;
}"
CreateElement "(tagname, orig_id) {
    element = CreateDictionary(
        'name', tagname,
        'attrs', CreateDictionary(),
        'children', CreateSparseArray(),
        'text', '',
        'tail', '',
        '_id', '',
        '_parent', null);

    if (orig_id = null)
    {
        element._id = generateRandomID();
    }
    else
    {
        element._id = orig_id;
    }

    f = Self._property:MEIFlattened;
    f[element._id] = element;

    return element;
}"
GetChildren "(element) {
        c = CreateSparseArray();
        for each child_id in element.children {
            child = Self.MEIFlattened[child_id];
            c.Push(child);
        }
        return c;
}"
SetChildren "(element, childarr) {
        element.children = childarr;
}"
AddChildAtPosition "(element, child, position) {
        AddChild(element, child);
        c = element.children;
        // shift all children that are at a higher index than `position`
        for i = c.Length - 1 to position step -1 {
            c[i] = c[i - 1];
        }
        element.children[position] = child._id;
}"
AddChild "(element, child) {
        cid = child._id;
        child._parent = element._id;
        element.children.Push(cid);
}"
RemoveChild "(element, child) {
    newarr = CreateSparseArray();

    for each elid in element.children
    {
        if (elid != child._id)
        {
            newarr.Push(elid);
        }
    }

    element.children = newarr;
}"
GetAttributes "(element) {
    return element.attrs;
}"
AddAttribute "(element, attrname, attrval) {
    a = element.attrs;
    // check and replace any newlines
    val = _encodeEntities(attrval);
    a[attrname] = val;
}"
AddAttributeValue "(element, attrname, attrval) {
    // appends a value to an existing attribute. Used, for example,
    // in appending multiple articulations to @artic on note.
    a = element.attrs;

    if (a.PropertyExists(attrname))
    {
        origval = a[attrname];
        newval = _encodeEntities(attrval);
        val = origval & ' ' & newval;
    }
    else
    {
        val = attrval;
    }

    element.attrs[attrname] = val;
}"
GetAttribute "(element, attrname) {
        attrs = element.attrs;
        if (attrs.PropertyExists(attrname))
        {
            return attrs[attrname];
        }
        else
        {
            return False;
        }
}"
SetAttributes "(element, new_attrs) {
    //sets all attributes, wiping out any previous ones
    element.attrs = CreateDictionary();

    // this will provide character encoding
    for each Pair a in new_attrs
    {
        AddAttribute(element, a.Name, a.Value);
    }
}"
GetId "(element) {
        return element._id;
}"
SetId "(element, value) {
        olddict = Self._property:MEIFlattened;
        oldid = element._id;

        newdict = removeKeyFromDictionary(olddict, oldid);
        element._id = value;
        newdict[value] = element;
        Self._property:MEIFlattened = newdict;
}"
RemoveAttribute "(element, attrname) {
    // since there are no delete functions
    // for dictionaries, we set the attribute
    // to a blank space and this will get
    // removed when converted to XML.
    element.attrs[attrname] = ' ';
}"
GetName "(element) {
    return element.name;
}"
SetText "(element, val) {
    element.text = _encodeEntities(val);
}"
GetText "(element) {
    return element.text;
}"
SetTail "(element, val) {
    element.tail = _encodeEntities(val);
}"
GetTail "(element) {
    return element.tail;
}"

    destroy "() {
        // cleans up
        Self._property:MEIFlattened = CreateDictionary();
        Self._property:MEIDocument = CreateSparseArray();
        Self._property:MEIID = 0;
    }"

    setDocumentRoot "(el) {
        d = Self._property:MEIDocument;
        d.Push(el);
    }"

    getDocumentRoot "() {
        d = Self._property:MEIDocument;
        return d[0];
    }"

    getDocument "() {
        return Self._property:MEIDocument;
    }"

    getElementById "(id) {
        d = Self._property:MEIFlattened;
        if (d.PropertyExists(id))
        {
            return d[id];
        }
        else
        {
            return null;
        }
    }"

    getElementsByName "(name) {
    if (not Self.MEIFlattened) {
        return false;
    }
    res = CreateSparseArray();
    for each e in Self.MEIFlattened {
        if (getName(e) = name) {
            res.Push(e);
        }
    }
    return res;
}"
    getPositionInDocument "(obj) {
    if (not Self.MEIFlattened) {
        return false;
    }
    for i = 0 to Length(Self.MEIFlattened) {
        if (Self.MEIFlattened[i] = obj) {
            return i;
        }
    }
    return false;
}"
    lookBack "(from, name) {
    if (not Self.MEIFlattened) {
        return false;
    }
    pos = getPositionInDocument(from);
    for i = pos to 0 step -1 {
        if (getName(Self.MEIFlattened[i]) = name) {
            return Self.MEIFlattened[i];
        }
    }
}"
    createXmlTag "(name, id, attributesList, isTerminal) {
    if (name = '<!--')
    {
        // handle XML comments
        return name;
    }

    attrstring = '';
    spacer = '';

    if (id != null)
    {
        attrstring = 'xml:id=' & Chr(34) & id & Chr(34);
    }

    if (attributesList != null)
    {
        spacer = ' ';
        for each Pair attr in attributesList
        {
            if (attr.Value != ' ')
            {
                if (attrstring = '')
                {
                    // Don't add initial space
                    attrstring = attr.Name & '=' & Chr(34) & attr.Value & Chr(34);
                }
                else
                {
                    attrstring = attrstring & spacer & attr.Name & '=' & Chr(34) & attr.Value & Chr(34);
                }
            }
        }
    }

    if (isTerminal)
    {
        return '<' & name & spacer & attrstring & '/>';
    }
    else
    {
        return '<' & name & spacer & attrstring & '>';
    }
}"
    convertDictToXml "(meiel, indent) {
    xmlout = '';
    terminalTag = true;

    nm = GetName(meiel);
    at = GetAttributes(meiel);
    ch = GetChildren(meiel);
    tx = GetText(meiel);
    tl = GetTail(meiel);
    id = GetId(meiel);

    tabs = '';
    if (indent > 0)
    {
        // add four spaces for every indent level.
        arr = utils.CreateArrayBlanket('    ', indent);
        tabs = JoinStrings(arr, '');
    }

    // comments are simple so they're handled specially.
    if (nm = '<!--')
    {
        xmlout = nm & ' ' & tx & ' -->' & Chr(10);
        return xmlout;
    }

    if (ch.Length > 0 or Length(tx) > 0)
    {
        terminalTag = false;
    }

    xmlout = createXmlTag(nm, id, at, terminalTag);

    if (Length(tx) > 0)
    {
        endchar = '';
        xmlout = xmlout & tx;

        // if an element has both text and children,
        // insert a line break.
        if (ch.Length > 0)
        {
            xmlout = xmlout & Chr(10);
        }
    }
    else
    {
        xmlout = xmlout & Chr(10);
    }

    if (ch.Length > 0)
    {
        indent = indent + 1;
        for each child in ch
        {
            xmlout = xmlout & tabs & convertDictToXml(child, indent);
        }
        indent = indent - 1;
    }

    // convertDictToXml takes care of adding the />
    // for tags that do not have children. We'll
    // take care of the terminal tag here for those
    // that do.
    if (not terminalTag)
    {
        if (ch.Length = 0 and Length(tx) > 0)
        {
            xmlout = xmlout & '</' & nm & '>' & Chr(10);
        }
        else
        {
            tabs = Substring(tabs, 0, Length(tabs) - 4);
            xmlout = xmlout & tabs & '</' & nm & '>' & Chr(10);
        }
    }

    if (Length(tl) > 0)
    {
        xmlout = xmlout & tabs & tl & Chr(10);
    }

    return xmlout;
}"

    _exportMeiDocument "(meidoc) {
        xdecl = '<?xml version=' & Chr(34) & '1.0' & Chr(34) & ' encoding=' & Chr(34) & 'UTF-16' & Chr(34) & ' ?>' & Chr(10);
        indent = 0;
        meiout = xdecl & convertDictToXml(meidoc[0], indent);

        return meiout;
    }"

    meiDocumentToFile "(meidoc, filename) {
        meiout = _exportMeiDocument(meidoc);
        if (Sibelius.CreateTextFile(filename)) {
            return Sibelius.AppendTextFile(filename, meiout, true);
        } else {
            return false;
        }
}"

    meiDocumentToString "(meidoc) {
        return _exportMeiDocument(meidoc);
    }"
    documentFromFile "(filename) {
    res = _xmlImport(filename);

    return res;
}"
    popMode "(arr) {
    if (arr.Length > 0) {
        return arr.Pop();
    } else {
        // return PRE
        return 15;
    }
}"
    _encodeEntities "(string)
    {
        /*
            Returns an entity-encoded version of the string.
        */
        if (string = '')
        {
            return string;
        }

        nc = Chr(10);
        quote = Chr(34);
        apos = Chr(39);
        lthan = Chr(60);
        gthan = Chr(62);
        amp = Chr(38);

        // &amp; must go first so it doesn't replace it in the character encoding
        string = utils.Replace(string, amp, '&amp;', true);
        string = utils.Replace(string, nc, '&#10;', true);
        string = utils.Replace(string, quote, '&quot;', true);
        string = utils.Replace(string, apos, '&apos;', true);
        string = utils.Replace(string, lthan, '&lt;', true);
        string = utils.Replace(string, gthan, '&gt;', true);

        return string;
    }"
    _xmlImport "(filename) {
    /*
        Based on the Quick-n-Dirty XML parser at
        https://www.infoworld.com/article/2077493/java-tip-128--create-a-quick-and-dirty-xml-parser.html
    */
    xmlinput = Sibelius.ReadTextFile(filename, true);
    meidoc = CreateSparseArray();
    TEXT = 1;
    ENTITY = 2;
    OPEN_TAG = 3;
    CLOSE_TAG = 4;
    START_TAG = 5;
    ATTRIBUTE_LVALUE = 6;
    ATTRIBUTE_EQUAL = 9;
    ATTRIBUTE_RVALUE = 10;
    QUOTE = 7;
    IN_TAG = 8;
    SINGLE_TAG = 12;
    COMMENT = 13;
    DONE = 11;
    DOCTYPE = 14;
    PRE = 15;
    CDATA = 16;

    mode = PRE;
    depth = 0;
    c = 0;
    quotec = Chr(34);
    sb = CreateSparseArray();
    etag = CreateSparseArray();
    tagName = '';
    lvalue = false;
    rvalue = false;
    attrs = CreateDictionary();
    st = CreateSparseArray();
    lnum = 1;
    col = 0;
    eol = false;
    parentTag = CreateSparseArray();

    for each line in xmlinput {
        for col = 0 to Length(line) {
            // col will be the character at that position in the line.
            c = CharAt(line, col);
            switch(mode) {
                case(DONE) {
                    //trace('done!');
                    return true;
                }
                // We are between tags collecting text.
                case(TEXT) {
                    //trace('text');
                    switch(c) {
                        case ('<') {
                            st.Push(mode);
                            mode = START_TAG;
                            if (sb.Length > 0) {
                                // something important goes on here...
                                // doc.text(sb.toString());
                                sb.Length = 0;
                            }
                        }
                        case ('&') {
                            st.Push(mode);
                            mode = ENTITY;
                            etag.Length = 0;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                // we are processing a closing tag: e.g. </foo>
                case (CLOSE_TAG) {
                    //trace('close tag');
                    if (c = '>') {
                        mode = popMode(st);
                        tagName = sb.Join('');
                        sb.Length = 0;
                        depth = depth - 1;
                        p = parentTag.Pop();
                        if (depth = 0) {
                            meidoc.Push(p);
                            mode = DONE;
                            // doc.endElement(tagName);
                        }
                    } else {
                        sb.Push(c);
                    }
                }
                // we are processing CDATA
                case (CDATA) {
                    //trace('cdata');
                    checktag = sb.Join('');
                    if (c = '>' and CharAt(checktag, -1) = ']]') {
                        sb.Length = sb.Length - 2;
                        // doc.text(sb.toString);
                        sb.Length = 0;
                        mode = popMode(st);
                    } else {
                        sb.Push(c);
                    }
                }
                // we are processing a comment.  We are inside
                // the <!-- .... --> looking for the -->.
                case (COMMENT) {
                    //trace('comment');
                    checktag = sb.Join('');
                    if (c = '>' and Substring(checktag, -2) = '--') {
                        sb.Length = 0;
                        mode = popMode(st);
                    } else {
                        sb.Push(c);
                    }
                }
                // We are outside the root tag element
                case (PRE) {
                    //trace('pre');
                    if (c = '<') {
                        mode = TEXT;
                        st.Push(mode);
                        mode = START_TAG;
                    }
                }
                // We are inside one of these <? ... ?>
                // or one of these <!DOCTYPE ... >
                case (DOCTYPE) {
                    //trace('doctype');
                    if (c = '>') {
                        mode = popMode(st);
                        if (mode = TEXT) {
                            mode = PRE;
                        }
                    }
                }
                // we have just seen a < and
                // are wondering what we are looking at
                // <foo>, </foo>, <!-- ... --->, etc.
                case (START_TAG) {
                    //trace('start tag');
                    mode = popMode(st);
                    switch(c) {
                        case ('/') {
                            st.Push(mode);
                            mode = CLOSE_TAG;
                        }
                        case ('?') {
                            mode = DOCTYPE;
                        }
                        default {
                            st.Push(mode);
                            mode = OPEN_TAG;
                            tagName = '';
                            attrs = CreateDictionary();
                            sb.Push(c);
                        }
                    }
                }
                // we are processing an entity, e.g. &lt;, &#187;, etc.
                case (ENTITY) {
                    //trace('entity');
                    if (c = ';') {
                        mode = popMode(st);
                        cent = etag.Join('');
                        etag.Length = 0;
                        switch (cent) {
                            case ('lt') {
                                sb.Push('<');
                            }
                            case ('gt') {
                                sb.Push('>');
                            }
                            case ('amp') {
                                sb.Push('&');
                            }
                            case ('quot') {
                                sb.Push(Chr(34));
                            }
                            case ('apos') {
                                sb.Push(Chr(39));
                            }
                            default {
                                if (CharAt(cent, 0) = '#') {
                                    sb.Push(Substring(cent, 1));
                                } else {
                                    trace('Unknown entity ' & cent & ' at line ' & lnum & ' and col ' & col);
                                }
                            }
                        }
                    } else {
                        etag.Push(c);
                    }
                }
                // we have just seen something like this:
                // <foo a='b '/
                // and are looking for the final >.
                case (SINGLE_TAG) {
                    //trace('single tag');
                    if (tagName = '') {
                        tagName = sb.Join('');
                    }
                    if (c != '>') {
                        trace('Expected > for tag: <' & tagName & '/> at line ' & lnum & ' and col ' & col);
                    }
                    // doc.startElement(tagName, attrs);
                    ent = createEntry(tagName);
                    setAttributes(ent, attrs);
                    addChild(parentTag[-1], ent);
                    Self.MEIFlattened.Push(ent);

                    // doc.endElement(tagName);
                    if (depth = 0) {
                        // doc.endDocument();
                        return true;
                    }
                    sb.Length = 0;
                    attrs = CreateDictionary();
                    tagName = '';
                    mode = popMode(st);
                }
                // we are processing something
                // like this <foo ... >.  It could
                // still be a <!-- ... --> or something.
                case (OPEN_TAG) {
                    //trace('open tag');
                    checktag = sb.Join('');
                    switch (c) {
                        case ('>') {
                            if (tagName = '') {
                                tagName = sb.Join('');
                            }
                            ent = createEntry(tagName);
                            setAttributes(ent, attrs);
                            addChild(parentTag[-1], ent);
                            parentTag.Push(ent);
                            Self.MEIFlattened.Push(ent);

                            sb.Length = 0;
                            depth = depth + 1;
                            tagName = '';
                            attrs = CreateDictionary();
                            mode = popMode(st);
                        }
                        case ('/') {
                            mode = SINGLE_TAG;
                        }
                        case ('-') {
                            if (checktag = '!-') {
                                //trace('checktag');
                                //trace(checktag);
                                mode = COMMENT;
                            }
                        }
                        case ('[') {
                            if (checktag = '![CDATA') {
                                mode = CDATA;
                                sb.Length = 0;
                            }
                        }
                        case ('E') {
                            if (checktag = '!DOCTYP') {
                                sb.Length = 0;
                                mode = DOCTYPE;
                            }
                        }
                        case (' ') {
                            tagName = sb.Join('');
                            sb.Length = 0;
                            mode = IN_TAG;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                // We are processing the quoted right-hand side
                // of an element's attribute.
                case (QUOTE) {
                    //trace('quote');
                    switch(c) {
                        case (quotec) {
                            rvalue = sb.Join('');
                            sb.Length = 0;
                            attrs[lvalue] = rvalue;
                            mode = IN_TAG;
                        }
                        // not sure what this does
                        case ('     ') {
                            sb.Push(' ');
                        }
                        case ('&') {
                            st.Push(mode);
                            mode = ENTITY;
                            etag.Length = 0;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                case (ATTRIBUTE_RVALUE) {
                    //trace('rvalue');
                    switch(c) {
                        case (Chr(34) or Chr(39)) {
                            quotec = c;
                            mode = QUOTE;
                        }
                        case (' ') {
                            ;
                        }
                        default {
                            trace('Error in attribute processing at line ' & lnum & ' col' & col);
                        }
                    }
                }
                case (ATTRIBUTE_LVALUE) {
                    //trace('lvalue');
                    switch (c) {
                        case (' ') {
                            lvalue = sb.Join('');
                            sb.Length = 0;
                            mode = ATTRIBUTE_EQUAL;
                        }
                        case ('=') {
                            lvalue = sb.Join('');
                            sb.Length = 0;
                            mode = ATTRIBUTE_RVALUE;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                case (ATTRIBUTE_EQUAL) {
                    //trace('equal');
                    switch (c) {
                        case ('=') {
                            mode = ATTRIBUTE_RVALUE;
                        }
                        case (' ') {
                            ;
                        }
                        default {
                            trace('Error in attribute processing at line ' & lnum & ' col' & col);
                        }
                    }
                }
                case (IN_TAG) {
                    //trace(parentTag);
                    //trace('in tag');
                    switch(c) {
                        case ('>') {
                            mode = popMode(st);
                            // doc.startElement(tagname, attrs);
                            ent = createEntry(tagName);
                            setAttributes(ent, attrs);
                            if (parentTag.Length > 0) {
                                addChild(parentTag[-1], ent);
                            }
                            parentTag.Push(ent);
                            Self.MEIFlattened.Push(ent);

                            depth = depth + 1;
                            tagName = '';
                            attrs = CreateDictionary();
                        }
                        case ('/') {
                            mode = SINGLE_TAG;
                        }
                        case (' ') {
                            ;
                        }
                        default {
                            mode = ATTRIBUTE_LVALUE;
                            sb.Push(c);
                        }
                    }
                }
            }
        }
        lnum = lnum + 1;
    }
    return meidoc;
}"

generateRandomID "() {
//$module(ExportGenerators.mss)
    id = Self._property:MEIID + 1;
    Self._property:MEIID = id;
    id = 'm-' & id;
    return id;
}"

removeKeyFromDictionary "(dict, key) {
    newdict = CreateDictionary();
    for each Pair p in dict
    {
        if (p.Name != key)
        {
            newdict[p.Name] = p.Value;
        }
    }

    return newdict;
}"

}
