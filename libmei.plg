
{
    
    _License "() {
    return 'Copyright (c) 2011-2013 Andrew Hankinson and Others

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    Software), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.';
    }"

    
	Arpeg "() {
    createEntry('arpeg');
}"

	BTrem "() {
    createEntry('bTrem');
}"

	Beam "() {
    createEntry('beam');
}"

	BeamSpan "() {
    createEntry('beamSpan');
}"

	BeatRpt "() {
    createEntry('beatRpt');
}"

	Bend "() {
    createEntry('bend');
}"

	Breath "() {
    createEntry('breath');
}"

	FTrem "() {
    createEntry('fTrem');
}"

	Fermata "() {
    createEntry('fermata');
}"

	Gliss "() {
    createEntry('gliss');
}"

	Hairpin "() {
    createEntry('hairpin');
}"

	HalfmRpt "() {
    createEntry('halfmRpt');
}"

	HarpPedal "() {
    createEntry('harpPedal');
}"

	MRest "() {
    createEntry('mRest');
}"

	MRpt "() {
    createEntry('mRpt');
}"

	MRpt2 "() {
    createEntry('mRpt2');
}"

	MSpace "() {
    createEntry('mSpace');
}"

	Measure "() {
    createEntry('measure');
}"

	MeterSig "() {
    createEntry('meterSig');
}"

	MeterSigGrp "() {
    createEntry('meterSigGrp');
}"

	MultiRest "() {
    createEntry('multiRest');
}"

	MultiRpt "() {
    createEntry('multiRpt');
}"

	Octave "() {
    createEntry('octave');
}"

	Ossia "() {
    createEntry('ossia');
}"

	Pedal "() {
    createEntry('pedal');
}"

	Reh "() {
    createEntry('reh');
}"

	Slur "() {
    createEntry('slur');
}"

	Tie "() {
    createEntry('tie');
}"

	Tuplet "() {
    createEntry('tuplet');
}"

	TupletSpan "() {
    createEntry('tupletSpan');
}"

	Mordent "() {
    createEntry('mordent');
}"

	Trill "() {
    createEntry('trill');
}"

	Turn "() {
    createEntry('turn');
}"

	MeiCorpus "() {
    createEntry('meiCorpus');
}"

	App "() {
    createEntry('app');
}"

	Lem "() {
    createEntry('lem');
}"

	Rdg "() {
    createEntry('rdg');
}"

	Abbr "() {
    createEntry('abbr');
}"

	Add "() {
    createEntry('add');
}"

	Choice "() {
    createEntry('choice');
}"

	Corr "() {
    createEntry('corr');
}"

	Damage "() {
    createEntry('damage');
}"

	Del "() {
    createEntry('del');
}"

	Expan "() {
    createEntry('expan');
}"

	Gap "() {
    createEntry('gap');
}"

	HandShift "() {
    createEntry('handShift');
}"

	Orig "() {
    createEntry('orig');
}"

	Reg "() {
    createEntry('reg');
}"

	Restore "() {
    createEntry('restore');
}"

	Sic "() {
    createEntry('sic');
}"

	Subst "() {
    createEntry('subst');
}"

	Supplied "() {
    createEntry('supplied');
}"

	Unclear "() {
    createEntry('unclear');
}"

	Facsimile "() {
    createEntry('facsimile');
}"

	Surface "() {
    createEntry('surface');
}"

	Zone "() {
    createEntry('zone');
}"

	Fig "() {
    createEntry('fig');
}"

	FigDesc "() {
    createEntry('figDesc');
}"

	Graphic "() {
    createEntry('graphic');
}"

	Table "() {
    createEntry('table');
}"

	Td "() {
    createEntry('td');
}"

	Th "() {
    createEntry('th');
}"

	Tr "() {
    createEntry('tr');
}"

	ComponentGrp "() {
    createEntry('componentGrp');
}"

	Expression "() {
    createEntry('expression');
}"

	ExpressionList "() {
    createEntry('expressionList');
}"

	Item "() {
    createEntry('item');
}"

	ItemList "() {
    createEntry('itemList');
}"

	Relation "() {
    createEntry('relation');
}"

	RelationList "() {
    createEntry('relationList');
}"

	Barre "() {
    createEntry('barre');
}"

	ChordDef "() {
    createEntry('chordDef');
}"

	ChordMember "() {
    createEntry('chordMember');
}"

	ChordTable "() {
    createEntry('chordTable');
}"

	F "() {
    createEntry('f');
}"

	Fb "() {
    createEntry('fb');
}"

	Harm "() {
    createEntry('harm');
}"

	AccessRestrict "() {
    createEntry('accessRestrict');
}"

	AcqSource "() {
    createEntry('acqSource');
}"

	AltId "() {
    createEntry('altId');
}"

	AppInfo "() {
    createEntry('appInfo');
}"

	Application "() {
    createEntry('application');
}"

	Audience "() {
    createEntry('audience');
}"

	Availability "() {
    createEntry('availability');
}"

	CaptureMode "() {
    createEntry('captureMode');
}"

	CarrierForm "() {
    createEntry('carrierForm');
}"

	Change "() {
    createEntry('change');
}"

	ChangeDesc "() {
    createEntry('changeDesc');
}"

	ClassCode "() {
    createEntry('classCode');
}"

	Classification "() {
    createEntry('classification');
}"

	Condition "() {
    createEntry('condition');
}"

	ContentItem "() {
    createEntry('contentItem');
}"

	Contents "() {
    createEntry('contents');
}"

	Context "() {
    createEntry('context');
}"

	Correction "() {
    createEntry('correction');
}"

	Dimensions "() {
    createEntry('dimensions');
}"

	EditionStmt "() {
    createEntry('editionStmt');
}"

	EditorialDecl "() {
    createEntry('editorialDecl');
}"

	EncodingDesc "() {
    createEntry('encodingDesc');
}"

	Ensemble "() {
    createEntry('ensemble');
}"

	Event "() {
    createEntry('event');
}"

	EventList "() {
    createEntry('eventList');
}"

	ExhibHist "() {
    createEntry('exhibHist');
}"

	FileChar "() {
    createEntry('fileChar');
}"

	FileDesc "() {
    createEntry('fileDesc');
}"

	Fingerprint "() {
    createEntry('fingerprint');
}"

	Hand "() {
    createEntry('hand');
}"

	HandList "() {
    createEntry('handList');
}"

	History "() {
    createEntry('history');
}"

	IncipCode "() {
    createEntry('incipCode');
}"

	IncipText "() {
    createEntry('incipText');
}"

	Inscription "() {
    createEntry('inscription');
}"

	InstrVoice "() {
    createEntry('instrVoice');
}"

	InstrVoiceGrp "() {
    createEntry('instrVoiceGrp');
}"

	Instrumentation "() {
    createEntry('instrumentation');
}"

	Interpretation "() {
    createEntry('interpretation');
}"

	Key "() {
    createEntry('key');
}"

	LangUsage "() {
    createEntry('langUsage');
}"

	Language "() {
    createEntry('language');
}"

	MeiHead "() {
    createEntry('meiHead');
}"

	Mensuration "() {
    createEntry('mensuration');
}"

	Meter "() {
    createEntry('meter');
}"

	Normalization "() {
    createEntry('normalization');
}"

	NotesStmt "() {
    createEntry('notesStmt');
}"

	OtherChar "() {
    createEntry('otherChar');
}"

	PerfMedium "() {
    createEntry('perfMedium');
}"

	PhysDesc "() {
    createEntry('physDesc');
}"

	PhysMedium "() {
    createEntry('physMedium');
}"

	PlateNum "() {
    createEntry('plateNum');
}"

	PlayingSpeed "() {
    createEntry('playingSpeed');
}"

	Price "() {
    createEntry('price');
}"

	ProjectDesc "() {
    createEntry('projectDesc');
}"

	Provenance "() {
    createEntry('provenance');
}"

	PubStmt "() {
    createEntry('pubStmt');
}"

	RevisionDesc "() {
    createEntry('revisionDesc');
}"

	SamplingDecl "() {
    createEntry('samplingDecl');
}"

	ScoreFormat "() {
    createEntry('scoreFormat');
}"

	Segmentation "() {
    createEntry('segmentation');
}"

	SeriesStmt "() {
    createEntry('seriesStmt');
}"

	SoundChan "() {
    createEntry('soundChan');
}"

	Source "() {
    createEntry('source');
}"

	SourceDesc "() {
    createEntry('sourceDesc');
}"

	SpecRepro "() {
    createEntry('specRepro');
}"

	StdVals "() {
    createEntry('stdVals');
}"

	SysReq "() {
    createEntry('sysReq');
}"

	TapeConfig "() {
    createEntry('tapeConfig');
}"

	Term "() {
    createEntry('term');
}"

	TermList "() {
    createEntry('termList');
}"

	TitleStmt "() {
    createEntry('titleStmt');
}"

	TreatHist "() {
    createEntry('treatHist');
}"

	TreatSched "() {
    createEntry('treatSched');
}"

	Unpub "() {
    createEntry('unpub');
}"

	UseRestrict "() {
    createEntry('useRestrict');
}"

	Watermark "() {
    createEntry('watermark');
}"

	Work "() {
    createEntry('work');
}"

	WorkDesc "() {
    createEntry('workDesc');
}"

	Timeline "() {
    createEntry('timeline');
}"

	When "() {
    createEntry('when');
}"

	Lyrics "() {
    createEntry('lyrics');
}"

	Verse "() {
    createEntry('verse');
}"

	Ligature "() {
    createEntry('ligature');
}"

	Mensur "() {
    createEntry('mensur');
}"

	Proport "() {
    createEntry('proport');
}"

	Cc "() {
    createEntry('cc');
}"

	Chan "() {
    createEntry('chan');
}"

	ChanPr "() {
    createEntry('chanPr');
}"

	Cue "() {
    createEntry('cue');
}"

	Hex "() {
    createEntry('hex');
}"

	InstrDef "() {
    createEntry('instrDef');
}"

	InstrGrp "() {
    createEntry('instrGrp');
}"

	Marker "() {
    createEntry('marker');
}"

	MetaText "() {
    createEntry('metaText');
}"

	Midi "() {
    createEntry('midi');
}"

	NoteOff "() {
    createEntry('noteOff');
}"

	NoteOn "() {
    createEntry('noteOn');
}"

	Port "() {
    createEntry('port');
}"

	Prog "() {
    createEntry('prog');
}"

	SeqNum "() {
    createEntry('seqNum');
}"

	TrkName "() {
    createEntry('trkName');
}"

	Vel "() {
    createEntry('vel');
}"

	CorpName "() {
    createEntry('corpName');
}"

	GeogName "() {
    createEntry('geogName');
}"

	PeriodName "() {
    createEntry('periodName');
}"

	PersName "() {
    createEntry('persName');
}"

	StyleName "() {
    createEntry('styleName');
}"

	Ineume "() {
    createEntry('ineume');
}"

	Syllable "() {
    createEntry('syllable');
}"

	Uneume "() {
    createEntry('uneume');
}"

	AvFile "() {
    createEntry('avFile');
}"

	Clip "() {
    createEntry('clip');
}"

	Performance "() {
    createEntry('performance');
}"

	Recording "() {
    createEntry('recording');
}"

	Ptr "() {
    createEntry('ptr');
}"

	Ref "() {
    createEntry('ref');
}"

	Accid "() {
    createEntry('accid');
}"

	Actor "() {
    createEntry('actor');
}"

	AddrLine "() {
    createEntry('addrLine');
}"

	Address "() {
    createEntry('address');
}"

	Annot "() {
    createEntry('annot');
}"

	Arranger "() {
    createEntry('arranger');
}"

	Artic "() {
    createEntry('artic');
}"

	Author "() {
    createEntry('author');
}"

	BarLine "() {
    createEntry('barLine');
}"

	Bibl "() {
    createEntry('bibl');
}"

	BiblList "() {
    createEntry('biblList');
}"

	BiblScope "() {
    createEntry('biblScope');
}"

	Body "() {
    createEntry('body');
}"

	Caption "() {
    createEntry('caption');
}"

	CastGrp "() {
    createEntry('castGrp');
}"

	CastItem "() {
    createEntry('castItem');
}"

	CastList "() {
    createEntry('castList');
}"

	Chord "() {
    createEntry('chord');
}"

	Clef "() {
    createEntry('clef');
}"

	ClefGrp "() {
    createEntry('clefGrp');
}"

	Composer "() {
    createEntry('composer');
}"

	Creation "() {
    createEntry('creation');
}"

	Custos "() {
    createEntry('custos');
}"

	Date "() {
    createEntry('date');
}"

	Dir "() {
    createEntry('dir');
}"

	Distributor "() {
    createEntry('distributor');
}"

	Dot "() {
    createEntry('dot');
}"

	Dynam "() {
    createEntry('dynam');
}"

	Edition "() {
    createEntry('edition');
}"

	Editor "() {
    createEntry('editor');
}"

	Ending "() {
    createEntry('ending');
}"

	Expansion "() {
    createEntry('expansion');
}"

	Extent "() {
    createEntry('extent');
}"

	Funder "() {
    createEntry('funder');
}"

	Fw "() {
    createEntry('fw');
}"

	Genre "() {
    createEntry('genre');
}"

	Group "() {
    createEntry('group');
}"

	GrpSym "() {
    createEntry('grpSym');
}"

	Identifier "() {
    createEntry('identifier');
}"

	Imprint "() {
    createEntry('imprint');
}"

	Incip "() {
    createEntry('incip');
}"

	KeyAccid "() {
    createEntry('keyAccid');
}"

	KeySig "() {
    createEntry('keySig');
}"

	Label "() {
    createEntry('label');
}"

	Layer "() {
    createEntry('layer');
}"

	LayerDef "() {
    createEntry('layerDef');
}"

	Lb "() {
    createEntry('lb');
}"

	Librettist "() {
    createEntry('librettist');
}"

	Lyricist "() {
    createEntry('lyricist');
}"

	Mdiv "() {
    createEntry('mdiv');
}"

	Mei "() {
    createEntry('mei');
}"

	Music "() {
    createEntry('music');
}"

	Name "() {
    createEntry('name');
}"

	Note "() {
    createEntry('note');
}"

	Num "() {
    createEntry('num');
}"

	P "() {
    createEntry('p');
}"

	Pad "() {
    createEntry('pad');
}"

	Part "() {
    createEntry('part');
}"

	Parts "() {
    createEntry('parts');
}"

	Pb "() {
    createEntry('pb');
}"

	PgDesc "() {
    createEntry('pgDesc');
}"

	PgFoot "() {
    createEntry('pgFoot');
}"

	PgFoot2 "() {
    createEntry('pgFoot2');
}"

	PgHead "() {
    createEntry('pgHead');
}"

	PgHead2 "() {
    createEntry('pgHead2');
}"

	Phrase "() {
    createEntry('phrase');
}"

	PhysLoc "() {
    createEntry('physLoc');
}"

	PubPlace "() {
    createEntry('pubPlace');
}"

	Publisher "() {
    createEntry('publisher');
}"

	Recipient "() {
    createEntry('recipient');
}"

	RelatedItem "() {
    createEntry('relatedItem');
}"

	Rend "() {
    createEntry('rend');
}"

	Repository "() {
    createEntry('repository');
}"

	Resp "() {
    createEntry('resp');
}"

	RespStmt "() {
    createEntry('respStmt');
}"

	Rest "() {
    createEntry('rest');
}"

	Role "() {
    createEntry('role');
}"

	RoleDesc "() {
    createEntry('roleDesc');
}"

	Sb "() {
    createEntry('sb');
}"

	Score "() {
    createEntry('score');
}"

	ScoreDef "() {
    createEntry('scoreDef');
}"

	Section "() {
    createEntry('section');
}"

	Series "() {
    createEntry('series');
}"

	Space "() {
    createEntry('space');
}"

	Sponsor "() {
    createEntry('sponsor');
}"

	Stack "() {
    createEntry('stack');
}"

	Staff "() {
    createEntry('staff');
}"

	StaffDef "() {
    createEntry('staffDef');
}"

	StaffGrp "() {
    createEntry('staffGrp');
}"

	Syl "() {
    createEntry('syl');
}"

	Tempo "() {
    createEntry('tempo');
}"

	TextLang "() {
    createEntry('textLang');
}"

	Title "() {
    createEntry('title');
}"

	TitlePage "() {
    createEntry('titlePage');
}"

	Back "() {
    createEntry('back');
}"

	Div "() {
    createEntry('div');
}"

	Front "() {
    createEntry('front');
}"

	Head "() {
    createEntry('head');
}"

	L "() {
    createEntry('l');
}"

	Lg "() {
    createEntry('lg');
}"

	Li "() {
    createEntry('li');
}"

	List "() {
    createEntry('list');
}"

	Quote "() {
    createEntry('quote');
}"

	AnchoredText "() {
    createEntry('anchoredText');
}"

	Curve "() {
    createEntry('curve');
}"

	Line "() {
    createEntry('line');
}"

	Symbol "() {
    createEntry('symbol');
}"

	SymbolDef "() {
    createEntry('symbolDef');
}"

	SymbolTable "() {
    createEntry('symbolTable');
}"

    createEntry "(tagname) {
    return CreateDictionary(tagname, CreateDictionary('attrs', CreateDictionary(), 'children', CreateSparseArray(), 'text', '', 'tail', ''));
}"
    getChildren "(obj) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    return el['children'];
}"
    setChildren "(obj, childarr) {
        trace(childarr.Type);
        props = obj.GetPropertyNames();
        objname = props[0];
        el = obj[objname];
        el['children'] = childarr;
}"
    addChildAtPosition "(obj, child, position) {
        c = getChildren(obj);
        r = CreateSparseArray();
        // copy the children to the new array. Add two
        // beyond the length since we'll be adding a new element.
        for i = c.Length + 2 {
            if (i = position) {
                r[i] = child;
                i = i + 1;
            } else {
                r[i] = c[i];
            }
        }
        setChildren(obj, r);
}"
    addChild "(obj, child) {
    c = getChildren(obj);
    c.Push(child);
}"
    getAttributes "(obj) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    return el['attrs'];
}"
    addAttribute "(obj, attrname, attrval) {
    a = getAttributes(obj);
    // check and replace any newlines
    nc = Chr(10);
    attrval = utils.Replace(attrval, nc, '&#10;', true);
    a[attrname] = attrval;
}"
    getAttribute "(obj, attrname) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    attrs = el['attrs'];
    if (attrs.PropertyExists(attrname)) {
        return attrs[attrname];
    } else {
        return false;
    }
}"
    setAttributes "(obj, attrs) {
    //sets all attributes, wiping out any previous ones
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    el['attrs'] = attrs;
}"
    removeAttribute "(obj, attrname) {
    // since there are no delete functions
    // for dictionaries, we set the attribute
    // to a blank space and this will get 
    // removed when converted to XML.
    a = getAttributes(obj);
    a[attrname] = ' ';
}"
    getName "(obj) {
    n = '';
    props = obj.GetPropertyNames();
    return props[0];
}"
    setText "(obj, val) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    el['text'] = val;
}"
    getText "(obj) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    return el['text'];
}"
    setTail "(obj, val) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    el['tail'] = val;
}"
    getTail "(obj) {
    props = obj.GetPropertyNames();
    objname = props[0];
    el = obj[objname];
    return el['tail'];
}"
    getElementsByName "(name) {
    if (not Self.flattened) {
        return false;
    }
    res = CreateSparseArray();
    for each e in Self.flattened {
        if (getName(e) = name) {
            res.Push(e);
        }
    }
    return res;
}"
getPositionInDocument "(obj) {
    if (not Self.flattened) {
        return false;
    }
    for i = 0 to Length(Self.flattened) {
        if (Self.flattened[i] = obj) {
            return i;
        }
    }
    return false;
}"

lookBack "(from, name) {
    if (not Self.flattened) {
        return false;
    }
    pos = getPositionInDocument(from);
    for i = pos to 0 step -1 {
        if (getName(Self.flattened[i]) = name) {
            return Self.flattened[i];
        }
    }
}"
    createXmlTag "(name, attributesList, isTerminal) {
    attrstring = '';
    spacer = '';
    if (attributesList) {
        spacer = ' ';
        for each Pair attr in attributesList {
            if (attr.Value != ' ') {
                if (attrstring = '') {
                    // Don't add initial space
                    attrstring = attr.Name & '=' & Chr(34) & attr.Value & Chr(34);
                }
                else {
                    attrstring = attrstring & spacer & attr.Name & '=' & Chr(34) & attr.Value & Chr(34);
                }
            }
        }
    }
    if (isTerminal) {
        return '<' & name & spacer & attrstring & '/>';
    } else {
        return '<' & name & spacer & attrstring & '>';
    }
}"
    convertDictToXml "(meiel, indent) {
    xmlout = '';
    terminalTag = true;
    nm = libmei.getName(meiel);
    at = libmei.getAttributes(meiel);
    ch = libmei.getChildren(meiel);
    tx = libmei.getText(meiel);
    tl = libmei.getTail(meiel);
    tabs = '';
    if (indent > 0) {
        // add four spaces for every indent level.
        arr = utils.CreateArrayBlanket('	', indent);
        tabs = JoinStrings(arr, '');
    }
    if (ch or Length(tx) > 0) {
        terminalTag = false;
    }

    xmlout = createXmlTag(nm, at, terminalTag);

    if (Length(tx) > 0) {
        endchar = '';
        xmlout = xmlout & tx;
    } else {
        xmlout = xmlout & '\n';
    }

    if (ch.Length > 0) {
        indent = indent + 1;
        for each child in ch {
            xmlout = xmlout & tabs & convertDictToXml(child, indent);
        }
        indent = indent - 1;
    }

    if (Length(tl) > 0) {
        xmlout = xmlout & tl;
    }

    // convertDictToXml takes care of adding the />
    // for tags that do not have children. We'll 
    // take care of the terminal tag here for those 
    // that do.
    if (not terminalTag) {
        if (Length(tx) > 0) {
            xmlout = xmlout & '</' & nm & '>\n';
        } else {
            tabs = Substring(tabs, 0, Length(tabs) - 1);
            xmlout = xmlout & tabs & '</' & nm & '>\n';
        }
    }

    return xmlout;
}"
    meiDocumentToFile "(meidoc, filename) {
    xdecl = '<?xml version=' & Chr(34) & '1.0' & Chr(34) & ' encoding=' & Chr(34) & 'UTF-8' & Chr(34) & ' ?>\n';
    indent = 0;
    meiout = xdecl & convertDictToXml(meidoc[0], indent);
    Sibelius.CreateTextFile(filename);
    Sibelius.AppendTextFile(filename, meiout, 1);

    return true;
}"
    documentFromFile "(filename) {
    Self._property:flattened = CreateSparseArray();
    res = _xmlImport(filename);

    return res;
}"
    popMode "(arr) {
    if (arr.Length > 0) {
        return arr.Pop();
    } else {
        // return PRE
        return 15;
    }
}"
    _xmlImport "(filename) {
    /* 
        Based on the Quick-n-Dirty XML parser at
        http://www.javaworld.com/javatips/jw-javatip128.html
    */
    xmlinput = Sibelius.ReadTextFile(filename, true);
    meidoc = CreateSparseArray();
    TEXT = 1;
    ENTITY = 2;
    OPEN_TAG = 3;
    CLOSE_TAG = 4;
    START_TAG = 5;
    ATTRIBUTE_LVALUE = 6;
    ATTRIBUTE_EQUAL = 9;
    ATTRIBUTE_RVALUE = 10;
    QUOTE = 7;
    IN_TAG = 8;
    SINGLE_TAG = 12;
    COMMENT = 13;
    DONE = 11;
    DOCTYPE = 14;
    PRE = 15;
    CDATA = 16;

    mode = PRE;
    depth = 0;
    c = 0;
    quotec = Chr(34);
    sb = CreateSparseArray();
    etag = CreateSparseArray();
    tagName = '';
    lvalue = false;
    rvalue = false;
    attrs = CreateDictionary();
    st = CreateSparseArray();
    lnum = 1;
    col = 0;
    eol = false;
    parentTag = CreateSparseArray();

    for each line in xmlinput {
        for col = 0 to Length(line) {
            // col will be the character at that position in the line.
            c = CharAt(line, col);
            switch(mode) {
                case(DONE) {
                    //trace('done!');
                    return true;
                }
                // We are between tags collecting text.
                case(TEXT) {
                    //trace('text');
                    switch(c) {
                        case ('<') {
                            st.Push(mode);
                            mode = START_TAG;
                            if (sb.Length > 0) {
                                // something important goes on here...
                                // doc.text(sb.toString());
                                sb.Length = 0;
                            }
                        }
                        case ('&') {
                            st.Push(mode);
                            mode = ENTITY;
                            etag.Length = 0;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                // we are processing a closing tag: e.g. </foo>
                case (CLOSE_TAG) {
                    //trace('close tag');
                    if (c = '>') {
                        mode = popMode(st);
                        tagName = sb.Join('');
                        sb.Length = 0;
                        depth = depth - 1;
                        p = parentTag.Pop();
                        if (depth = 0) {
                            meidoc.Push(p);
                            mode = DONE;
                            // doc.endElement(tagName);
                        }
                    } else {
                        sb.Push(c);
                    }
                }
                // we are processing CDATA
                case (CDATA) {
                    //trace('cdata');
                    checktag = sb.Join('');
                    if (c = '>' and CharAt(checktag, -1) = ']]') {
                        sb.Length = sb.Length - 2;
                        // doc.text(sb.toString);
                        sb.Length = 0;
                        mode = popMode(st);
                    } else {
                        sb.Push(c);
                    }
                }
                // we are processing a comment.  We are inside
                // the <!-- .... --> looking for the -->.
                case (COMMENT) {
                    //trace('comment');
                    checktag = sb.Join('');
                    if (c = '>' and Substring(checktag, -2) = '--') {
                        sb.Length = 0;
                        mode = popMode(st);
                    } else {
                        sb.Push(c);
                    }
                }
                // We are outside the root tag element
                case (PRE) {
                    //trace('pre');
                    if (c = '<') {
                        mode = TEXT;
                        st.Push(mode);
                        mode = START_TAG;
                    }
                }
                // We are inside one of these <? ... ?>
                // or one of these <!DOCTYPE ... >
                case (DOCTYPE) {
                    //trace('doctype');
                    if (c = '>') {
                        mode = popMode(st);
                        if (mode = TEXT) {
                            mode = PRE;
                        }
                    }
                }
                // we have just seen a < and
                // are wondering what we are looking at
                // <foo>, </foo>, <!-- ... --->, etc.
                case (START_TAG) {
                    //trace('start tag');
                    mode = popMode(st);
                    switch(c) {
                        case ('/') {
                            st.Push(mode);
                            mode = CLOSE_TAG;
                        }
                        case ('?') {
                            mode = DOCTYPE;
                        }
                        default {
                            st.Push(mode);
                            mode = OPEN_TAG;
                            tagName = '';
                            attrs = CreateDictionary();
                            sb.Push(c);
                        }
                    }
                }
                // we are processing an entity, e.g. &lt;, &#187;, etc.
                case (ENTITY) {
                    //trace('entity');
                    if (c = ';') {
                        mode = popMode(st);
                        cent = etag.Join('');
                        etag.Length = 0;
                        switch (cent) {
                            case ('lt') {
                                sb.Push('<');
                            }
                            case ('gt') {
                                sb.Push('>');
                            }
                            case ('amp') {
                                sb.Push('&');
                            }
                            case ('quot') {
                                sb.Push(Chr(34));
                            }
                            case ('apos') {
                                sb.Push(Chr(39));
                            }
                            default {
                                if (CharAt(cent, 0) = '#') {
                                    sb.Push(Substring(cent, 1));
                                } else {
                                    trace('Unknown entity ' & cent & ' at line ' & lnum & ' and col ' & col);
                                }
                            }
                        }
                    } else {
                        etag.Push(c);
                    }
                }
                // we have just seen something like this:
                // <foo a='b '/
                // and are looking for the final >.
                case (SINGLE_TAG) {
                    //trace('single tag');
                    if (tagName = '') {
                        tagName = sb.Join('');
                    }
                    if (c != '>') {
                        trace('Expected > for tag: <' & tagName & '/> at line ' & lnum & ' and col ' & col);
                    }
                    // doc.startElement(tagName, attrs);
                    ent = createEntry(tagName);
                    libmei.setAttributes(ent, attrs);
                    libmei.addChild(parentTag[-1], ent);
                    Self.flattened.Push(ent);

                    // doc.endElement(tagName);
                    if (depth = 0) {
                        // doc.endDocument();
                        return true;
                    }
                    sb.Length = 0;
                    attrs = CreateDictionary();
                    tagName = '';
                    mode = popMode(st);
                }
                // we are processing something
                // like this <foo ... >.  It could
                // still be a <!-- ... --> or something.
                case (OPEN_TAG) {
                    //trace('open tag');
                    checktag = sb.Join('');
                    switch (c) {
                        case ('>') {
                            if (tagName = '') {
                                tagName = sb.Join('');
                            }
                            ent = createEntry(tagName);
                            libmei.setAttributes(ent, attrs);
                            libmei.addChild(parentTag[-1], ent);
                            parentTag.Push(ent);
                            Self.flattened.Push(ent);

                            sb.Length = 0;
                            depth = depth + 1;
                            tagName = '';
                            attrs = CreateDictionary();
                            mode = popMode(st);
                        }
                        case ('/') {
                            mode = SINGLE_TAG;
                        }
                        case ('-') {
                            if (checktag = '!-') {
                                //trace('checktag');
                                //trace(checktag);
                                mode = COMMENT;
                            }
                        }
                        case ('[') {
                            if (checktag = '![CDATA') {
                                mode = CDATA;
                                sb.Length = 0;
                            }
                        }
                        case ('E') {
                            if (checktag = '!DOCTYP') {
                                sb.Length = 0;
                                mode = DOCTYPE;
                            }
                        }
                        case (' ') {
                            tagName = sb.Join('');
                            sb.Length = 0;
                            mode = IN_TAG;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                // We are processing the quoted right-hand side
                // of an element's attribute.
                case (QUOTE) {
                    //trace('quote');
                    switch(c) {
                        case (quotec) {
                            rvalue = sb.Join('');
                            sb.Length = 0;
                            attrs[lvalue] = rvalue;
                            mode = IN_TAG;
                        }
                        // not sure what this does
                        case (' \u0009') {
                            sb.Push(' ');
                        }
                        case ('&') {
                            st.Push(mode);
                            mode = ENTITY;
                            etag.Length = 0;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                case (ATTRIBUTE_RVALUE) {
                    //trace('rvalue');
                    switch(c) {
                        case (Chr(34) or Chr(39)) {
                            quotec = c;
                            mode = QUOTE;
                        }
                        case (' ') {
                            ;
                        }
                        default {
                            trace('Error in attribute processing at line ' & lnum & ' col' & col);
                        }
                    }
                }
                case (ATTRIBUTE_LVALUE) {
                    //trace('lvalue');
                    switch (c) {
                        case (' ') {
                            lvalue = sb.Join('');
                            sb.Length = 0;
                            mode = ATTRIBUTE_EQUAL;
                        }
                        case ('=') {
                            lvalue = sb.Join('');
                            sb.Length = 0;
                            mode = ATTRIBUTE_RVALUE;
                        }
                        default {
                            sb.Push(c);
                        }
                    }
                }
                case (ATTRIBUTE_EQUAL) {
                    //trace('equal');
                    switch (c) {
                        case ('=') {
                            mode = ATTRIBUTE_RVALUE;
                        }
                        case (' ') {
                            ;
                        }
                        default {
                            trace('Error in attribute processing at line ' & lnum & ' col' & col);
                        }
                    }
                }
                case (IN_TAG) {
                    //trace(parentTag);
                    //trace('in tag');
                    switch(c) {
                        case ('>') {
                            mode = popMode(st);
                            // doc.startElement(tagname, attrs);
                            ent = createEntry(tagName);
                            libmei.setAttributes(ent, attrs);
                            if (parentTag.Length > 0) {
                                libmei.addChild(parentTag[-1], ent);
                            }
                            parentTag.Push(ent);
                            Self.flattened.Push(ent);

                            depth = depth + 1;
                            tagName = '';
                            attrs = CreateDictionary();
                        }
                        case ('/') {
                            mode = SINGLE_TAG;
                        }
                        case (' ') {
                            ;
                        }
                        default {
                            mode = ATTRIBUTE_LVALUE;
                            sb.Push(c);
                        }
                    }
                }
            }
        }
        lnum = lnum + 1;
    }
    return meidoc;
}"
}
